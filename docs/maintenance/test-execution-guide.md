# テスト実行のベストプラクティス

## 1. WSL環境でのテスト実行

### 発生した問題
- WSLでのテスト実行時にメモリ不足によりプロセスが強制終了
- Windsurfの異常終了
- テストプロセスがSIGKILLシグナルで終了

### 解決策
1. シリアルテスト実行
```bash
jest --runInBand --verbose
```
- 同時実行を避けメモリ使用量を抑制
- テスト実行の安定性向上
- エラーの追跡が容易に

2. テストタイムアウトの調整
```typescript
describe('長時間かかるテスト', () => {
  it('should complete', () => {
    // タイムアウトを30秒に延長
  }, 30000);
});
```

3. メモリリークの検出
```bash
jest --detectOpenHandles
```
- 未解放のリソースを特定
- クリーンアップ漏れの発見

## 2. テストコードの改善ポイント

### クリーンアップの徹底
```typescript
afterEach(() => {
  // モックのリセット
  jest.clearAllMocks();
  // タイマーのクリア
  jest.useRealTimers();
});

afterAll(() => {
  // 外部リソースの解放
  // 接続のクローズ
});
```

### リソース管理
- タイマーを使用する場合は`.unref()`を呼び出す
- 外部接続は確実にクローズ
- モックデータは適切にクリーンアップ

## 3. テストカバレッジ

### 重点的に改善が必要な領域
- validation.ts (61.29%)
- pdf.ts (73.68%)

### カバレッジ改善のアプローチ
1. エッジケースのテスト追加
2. エラーハンドリングのテスト強化
3. 境界値テストの実装

## 4. CI/CD環境での設定

### package.jsonの推奨設定
```json
{
  "scripts": {
    "test": "jest --runInBand --verbose",
    "test:coverage": "jest --runInBand --coverage",
    "test:debug": "jest --runInBand --verbose --detectOpenHandles"
  }
}
```

## 5. 定期的なメンテナンス

### チェックリスト
- [ ] テストの実行時間の監視
- [ ] メモリ使用量の確認
- [ ] 失敗するテストの分析
- [ ] カバレッジレポートの確認
- [ ] 非同期処理の適切な処理

## 6. 継続的な監視と改善

### 予防的な監視
- テスト実行時のメモリ使用量を定期的に監視
- 新しいテストケース追加時は特に注意深く観察
- 大規模なテストを追加する際は、事前にメモリ消費量を見積もり

### 特別な注意が必要なケース
- 大量のデータを扱うテスト
  - データセットのサイズを適切に制限
  - メモリ効率の良いデータ構造を使用
- 外部リソースを多用するテスト
  - モックの活用を検討
  - リソースの確実な解放を確認
- 非同期処理が複雑に絡むテスト
  - タイムアウト設定の最適化
  - Promise chainの適切な管理

### 継続的な改善プロセス
1. 定期的なレビュー
   - テストコードの品質チェック
   - パフォーマンスボトルネックの特定
   - 重複するテストの統合検討

2. 知見の共有
   - チーム内でのテスト実行経験の共有
   - 問題発生時の解決方法の記録
   - ベストプラクティスの更新

3. ドキュメントのメンテナンス
   - 新しい問題や解決策の追加
   - 古くなった情報の更新
   - 実際の経験に基づく改善点の反映

## 7. エラーハンドリングのベストプラクティス

### エラー型の統一
```typescript
// カスタムエラークラスの例
class CustomError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly status: number
  ) {
    super(message);
    this.name = 'CustomError';
  }
}
```

### エラーレスポンスの形式
```typescript
interface ErrorResponse {
  code: string;        // エラーコード
  message: string;     // エラーメッセージ
  details?: unknown;   // 追加情報（オプション）
}
```

### エラー処理の優先順位
1. 認証エラー（401, 403）
2. バリデーションエラー（400）
3. 外部サービスエラー（500系）
4. その他の内部エラー（500）

## 8. テストカバレッジ改善戦略

### 優先順位の決定
1. セキュリティ関連（認証、バリデーション）
2. コアロジック（ビジネスロジック）
3. 外部サービス連携
4. ユーティリティ機能

### テスト実装の手順
1. 依存関係の分析
   - 外部サービスの特定
   - 必要なモックの準備
   - テストデータの用意

2. テストケースの設計
   - 正常系のテスト
   - エラーケースのテスト
   - エッジケースの考慮

3. 実装とリファクタリング
   - シンプルなケースから開始
   - テストコードの重複を避ける
   - 適切な抽象化レベルの維持

### カバレッジ目標
| 優先度 | 目標カバレッジ | 対象コンポーネント |
|-------|--------------|-----------------|
| 高    | 90%以上      | 認証、バリデーション |
| 中    | 80%以上      | ビジネスロジック   |
| 低    | 70%以上      | ユーティリティ     |

### メンテナンス性の向上
1. テストケースの整理
   - 関連するテストをグループ化
   - 適切な命名規則の適用
   - テストの目的を明確に記述

2. モックの管理
   - 再利用可能なモックの作成
   - モックデータの一元管理
   - モックの更新手順の明確化
